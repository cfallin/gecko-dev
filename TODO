- (x) Clean up the PBL execution model
  - Put the IC invocation loop into the ICs themselves; minimize the size of
    the body in the interpreter loop (just one unconditional function call)
  - Put any context needed for JSOp and IC interpreters in a struct, and ensure
    that all signatures are <= 4 args for ABI efficiency on Wasm

  - end goal: JSOp interpreter calls a single invocation of IC interpreter; that
    ends with a loop that invokes IC interpreter again if needed; fallback is
    incorporated into that somehow

- (x) update weval to have a "symbolic memory at this ptr, len" abstraction

- (x) import latest weval header and Weval abstraction built around it

- (x) incorporate wevaled main function bodies
  - specialization-mode template parameters

- (x) separate warmup count for TryAttachStub attempts (otherwise in
  wevaled builds with force-PBL we will attach in every cold path)

- (x) build functionality to dump all weval'ing requests after
  running, save them, and pre-weval later

- (x) weval IC bodies

- trim out unneeded logic in weval'd bodies:
  - observability
    - get line-number marks in weval'd wasm
    - get profiler to provide line-number info
    - put opcode in weval context / basic-block names?
  - (x) hybrid ICs still a thing?
  - make sure SP is in a register and not constantly reloaded
  - debuggee checks
  - profiling counts?
  - extra pointer-chain indirections when updating e.g. IC pointer
  - (x) pass IC args as registers (avoid some memory traffic)
  - avoid conditional at IC site; always indirect call
  - (x) run with no-sig-check, no-stack-limit, no-null-check,
    no-table-bounds-check wasmtime
  - (x) make LoopHeader and JumpTarget much more efficient (keep
    ICEntries in a local; also cache interpreterICEntry?)
  - stack push/pop logic? pc/sp updates? current-IC pointer in frame?
  - (x) GOT loads: treat a load of any non-zero-index global as a load
    of constant memory, and optimize it as such
  - (x) escape analysis on stack-pointer global, to remove it from IC
    body?
  - bad regalloc -- give stack args proper constraints, and don't load
  - stack primitives for loading ("write-through cache")?
  - SIMD to pass args in regs and return ic result without
    intermediate memory access
  - fast IC (typed funcrefs) to remove a few levels of indirection --
    no fetch of raw code pointer from ICEntry (heap)-> firstStub
    (heap)-> rawJitCode, instead a load from table[constant]

- collect ICs from Octane (script to do this)
- ensure Octane works (resolve unset-register-3 issue?)
- build cached-weval (incremental compilation) approach

- "fast IC invocation" mechanism: typed funcref table, fixed indices
  in wevaled body, return updated funcref? or set it separately when
  setting IC head?
  - declare that the "fast funcptr" mechanism handles just one
    signature -- say `(i32, i32, i32, i32) -> i32`.
  - two new tables: typed funcref table for all weval'd bodies of this
    signature; typed funcref table for all callsites. add a new
    function (and link calls to `weval_update_fast_funcptr` to it)
    that copies from former to latter.
  - weval request fills in fast-funcptr (if sig matches) alongside
    normal funcptr.
  - intrinsic to invoke fast-funcptr if available; i32 return; if
    returns nonzero then do slow funcptr call; constant-fold this.
