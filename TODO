- (x) Clean up the PBL execution model
  - Put the IC invocation loop into the ICs themselves; minimize the size of
    the body in the interpreter loop (just one unconditional function call)
  - Put any context needed for JSOp and IC interpreters in a struct, and ensure
    that all signatures are <= 4 args for ABI efficiency on Wasm

  - end goal: JSOp interpreter calls a single invocation of IC interpreter; that
    ends with a loop that invokes IC interpreter again if needed; fallback is
    incorporated into that somehow

- (x) update weval to have a "symbolic memory at this ptr, len" abstraction

- (x) import latest weval header and Weval abstraction built around it

- (x) incorporate wevaled main function bodies
  - specialization-mode template parameters

- (x) separate warmup count for TryAttachStub attempts (otherwise in
  wevaled builds with force-PBL we will attach in every cold path)

- (x) build functionality to dump all weval'ing requests after
  running, save them, and pre-weval later

- (x) weval IC bodies

- trim out unneeded logic in weval'd bodies:
  - observability
    - get line-number marks in weval'd wasm
    - get profiler to provide line-number info
    - put opcode in weval context / basic-block names?
  - (x) hybrid ICs still a thing?
  - make sure SP is in a register and not constantly reloaded
  - debuggee checks
  - profiling counts?
  - extra pointer-chain indirections when updating e.g. IC pointer
  - (x) pass IC args as registers (avoid some memory traffic)
  - avoid conditional at IC site; always indirect call
  - (x) run with no-sig-check, no-stack-limit, no-null-check,
    no-table-bounds-check wasmtime
  - (x) make LoopHeader and JumpTarget much more efficient (keep
    ICEntries in a local; also cache interpreterICEntry?)
  - stack push/pop logic? pc/sp updates? current-IC pointer in frame?
  - (x) GOT loads: treat a load of any non-zero-index global as a load
    of constant memory, and optimize it as such
  - (x) escape analysis on stack-pointer global, to remove it from IC
    body?
  - (x) SIMD to pass args in regs and return ic result without
    intermediate memory access
  - (x) packed IC return
    - return IC result directly via packed XMM, not through memory;
      use this when no need to go through Wasm stack (e.g. ToBool)
    - (NO) actually a 5% slowdown -- saved as branch
      cfallin/pbl-weval-2024-packed-ic-returns.

  - fast IC (typed funcrefs)
    - to remove a few levels of indirection -- no fetch of raw code
      pointer from ICEntry (heap)-> firstStub (heap)-> rawJitCode,
      instead a load from table[constant]
    - new mechanism:
      - fast_dispatch intrinsic takes a "cache key" and funcptr; user
        promises funcptr is same if cache key remains same. For ICs,
        use ICStub pointer as cache key.
      - in wevaled function bodies, alloc two globals per fast
        dispatch site: last seen cache key, and typed funcref.
      - this replaces:
        - load icstub->stubinfo
          - load stubinfo->jitcode
            - load vmctx->table_base
            - load table_base[jitcode]
              - load anyfunc->code
              - load anyfunc->calleectx
      - with:
        - load vmctx->last_icstub
        - load vmctx->last_anyfunc
          - load anyfunc->code
          - load anyfunc->calleectx
      - so 6->4 loads, and two levels of dependent-load removed
      - note: generate a "clear all cached funcptrs" function too, and
        call this (via intrinsic) in GC. otherwise stale ICStub keys
        could have false positives.
  - renamed stack
    - stack primitives for loading ("write-through cache")? Elide
      push/pop with no calls between?
    - basically the old "memory renaming", with flush on call
    - JS locals?
  - PortableBaselineInterpret prologue cleanup
    - all unnecessary prologue from PBI (recursion limit, debug checks,
      profiling counters, ...)

  - optimize ICs more for specific benchmarks/cases
    - take a look at NavierStokes?

- collect ICs from Octane (script to do this)
- ensure Octane works (resolve unset-register-3 issue?)
- build cached-weval (incremental compilation) approach

- "fast IC invocation" mechanism: typed funcref table, fixed indices
  in wevaled body, return updated funcref? or set it separately when
  setting IC head?
  - declare that the "fast funcptr" mechanism handles just one
    signature -- say `(i32, i32, i32, i32) -> i32`.
  - two new tables: typed funcref table for all weval'd bodies of this
    signature; typed funcref table for all callsites. add a new
    function (and link calls to `weval_update_fast_funcptr` to it)
    that copies from former to latter.
  - weval request fills in fast-funcptr (if sig matches) alongside
    normal funcptr.
  - intrinsic to invoke fast-funcptr if available; i32 return; if
    returns nonzero then do slow funcptr call; constant-fold this.
