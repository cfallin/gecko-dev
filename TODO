- (x) Clean up the PBL execution model
  - Put the IC invocation loop into the ICs themselves; minimize the size of
    the body in the interpreter loop (just one unconditional function call)
  - Put any context needed for JSOp and IC interpreters in a struct, and ensure
    that all signatures are <= 4 args for ABI efficiency on Wasm

  - end goal: JSOp interpreter calls a single invocation of IC interpreter; that
    ends with a loop that invokes IC interpreter again if needed; fallback is
    incorporated into that somehow

- (x) update weval to have a "symbolic memory at this ptr, len" abstraction

- (x) import latest weval header and Weval abstraction built around it

- (x) incorporate wevaled main function bodies
  - specialization-mode template parameters

- build functionality to dump all weval'ing requests after running, save them,
  and pre-weval later
  - generate a function that somehow does a hashtable lookup?

- separate warmup count for TryAttachStub attempts (otherwise in
  wevaled builds with force-PBL we will attach in every cold path)

- weval IC bodies

- "fast IC invocation" mechanism: typed funcref table, fixed indices
  in wevaled body, return updated funcref? or set it separately when
  setting IC head?
  - declare that the "fast funcptr" mechanism handles just one
    signature -- say `(i32, i32, i32, i32) -> i32`.
  - two new tables: typed funcref table for all weval'd bodies of this
    signature; typed funcref table for all callsites. add a new
    function (and link calls to `weval_update_fast_funcptr` to it)
    that copies from former to latter.
  - weval request fills in fast-funcptr (if sig matches) alongside
    normal funcptr.
  - intrinsic to invoke fast-funcptr if available; i32 return; if
    returns nonzero then do slow funcptr call; constant-fold this.
