- weval
  X get specialized/generic-bailout architecture working
    - add a config option to test it
  X add intrinsics for memory-constantness and for interpreter loop
  X add specialization requests at call-points
  X add specialization requests when creating JSScripts (and put the weval state
    in JSScript instead of JitScript)
  X get Octane passing
  - === milestone 1: weval of JSOp loop
  X add pointers on ICStubs for specialized funcs
  X add weval intrinsics to IC loop
  X add CacheIRWriter bodies for common ICs (find a way to collect these: print
    in CacheIRWriter?)
  - === milestone 2: weval'd IC stubs
  X add stack-renaming and renaming for icregs
  - ensure that IC invocation code is minimized (put error-case switch off the
    critical path, ensure it's not in PC-specialized code)
  X No hybrid ICs in specialized bodies? (Collect common ICs for this too)
  - Replace OOL stuff with unified template-specialized code
  X Minimize args (four args only on x86-64) to avoid stack arg-passing to ICs
  X Switch to a tail-call (or just normal call-chaining) design; uniformly use
    pointer to either ICInterpretOps or specialized func; minimize size of IC
    callsite
    - define a new signature and a wrapper that invokes
      ICInterpretOps, then tail-calls next func
    - set jitcode pointer in IC stubs to cast function pointer from
      weval state in CacheIRStubInfo
    - if not set, set to a wrapper function that invokes IC interpreter
    - set jitcode pointer in fallback stubs to a wrapper that invokes
      fallback
    - at tail of ICInterpretOps, invoke next stub's function, if
      template parameter is set appropriately
    - invoke jitcode pointer directly from IC site in specialized
      version of function bodies
  X debug tail-call variant (crashes on deltablue)
  - make sure tail-call variant preserves interp perf
    - maybe icsite should be a static if-else to call either icinterpretops or
      the appropriate fallback...
  - implement more missing CacheOps (at least AddAndStore... slot ops)
  - push IC-site return-value switch past an ensure_generic; only check a bool
    (put interpResult in PBLCtx)
  - conserve args: get `code` from const `stubInfo`; add field to weval req to
    delete constant args, and delete `stubInfo` in specialized variant; now we
    have two args for IC args (plus ctx and stub instance)
  - return icResult instead, and put failure flag in PBLCtx? Then we have a
    load after every IC chain returns, but common-case data path is through
    registers, and we don't have a store to "fail" flag in common case
  - try ICs for binops etc again, once IC-site overhead is smaller
  - === milestone 3: opts
  - add a "binary dump" of IC bodies via an env var; do this across all tests;
    pass this binary as a blob into engine init; keep reference to it, and use
    it when initializing new Realms
  - === milestone 4: cleanup

- PBL
  - async resume (v2 -- fix perf regression)
  - constructor-call fastpath (Jamey)
  - all IC ops (Jamey)
